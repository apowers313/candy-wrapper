<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>candy-wrapper.js - Candy Wrapper</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Candy Wrapper" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/.html"></a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: candy-wrapper.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
// UMD returnExports design pattern
(function(root, factory) {
    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof module === &quot;object&quot; &amp;&amp; module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.CandyWrapper = factory();
    }
}(this, function() {

    function debug(...args) {
        console.log(...args);
    }

    var wrapperCookie = &quot;193fe616-09d1-4d5c-a5b9-ff6f3e79714c&quot;;

    class Expect {
        constructor() {
            this.futureMatch = [];
        }

        addDeferredAction(name, args) {
            var action = {
                name: name,
                args: args
            };
            console.log (&quot;adding action:&quot;, action);
            this.actionList.push(action);
        }

        getCurrCallOrDefer(name, ...args) {
            console.log (&quot;getCurrCallOrDefer&quot;);
            if (this instanceof SingleInvocation) return this;
            console.log (&quot;checking currCall&quot;);
            if (this instanceof Trigger &amp;&amp; this.currentCall instanceof SingleInvocation) return this.currentCall;
            console.log (&quot;deferring&quot;);
            var argArray = [...args];
            if (typeof this.addDeferredAction === &quot;function&quot;) this.addDeferredAction(name, argArray);
        }

        expectDoValidation(si) {
            this[this.expectType](si, this.expectParam);
        }

        expectCallArgs(...args /*, siRef */ ) {
            var passed = false;
            var newSi = new SingleInvocation();
            newSi.argList = args;
            var siRef;

            if (arguments.length === 2 &amp;&amp; arguments[1] instanceof SingleInvocation) {
                siRef = arguments[1];
            } else if (arguments.length !== 1 || !Array.isArray(args)) {
                throw new TypeError(&quot;expectCallArgs: expected a single args array for an argument&quot;);
            }

            var match = new Match(siRef);

            // if future evaluation, save the match
            this.futureMatch.push(new Match(siRef));

            // if evaluate now, check and return
            match.compare(siRef);

            return passed;
        }

        // expectCallArgs(si)
        // expectContext(si)
        // expectReturn(si)
        // expectException(si)
        // expectCustom (fn, param)
    }

    /**
     * Creates a new function wrapper -- a spy, stub, mock, etc.
     * @class
     */
    class Wrapper extends Function {
        /**
         * This is a constructor
         * @return {Wrapper} Proxy around a Wrapper object
         */
        constructor() {
            super();

            // forms of wrapper:
            // wrapper()
            // wrapper(obj)
            // wrapper(func)
            // wrapper(obj, method)
            // wrapper(obj, attribute)
            // wrapper(obj, method, func)
            // wrapper(obj, attribute, func)

            // constructed like: wrapper()
            if (arguments.length === 0) {
                debug(&quot;creating empty wrapper&quot;);
                this.wrapped = function() {};
            }

            // constructed like: wrapper(obj)
            /**
             * Wrap all aspects of an object
             * @param  {Object} obj Object to be wrapped
             * @return {Object}    Returns an object with all methods and attributes wrapped
             * @lends Wrapper
             * @constructor
             */
            if (arguments.length === 1 &amp;&amp; typeof arguments[0] === &quot;object&quot;) {
                debug(&quot;wrapping object&quot;);
            }

            // constructed like: wrapper(func)
            /**
             * Puts a wrapper around a function and returns it
             * @param  {Function} fn Function to be wrapped
             * @return {Wrapper}    Returns the a Proxy for a Wrapper around the function
             * @constructs
             * @memberof Wrapper
             */
            if (arguments.length === 1 &amp;&amp; typeof arguments[0] === &quot;function&quot;) {
                debug(&quot;wrapping function&quot;);
                this.wrapped = arguments[0];
            }

            // set default values
            this.configReset();

            this.chainable = new Proxy(this, {
                apply: (target, thisArg, argList) =&gt; this._doCall(target, thisArg, argList)
            });

            return this.chainable;
        }

        _doCall(target, thisArg, argList) {
            var funcName = this.wrapped.name || &quot;&lt;&lt;anonymous&gt;&gt;&quot;;
            debug(&#x60;calling wrapper on &quot;${funcName}&quot;&#x60;);

            var si = new SingleInvocation(thisArg, argList);

            // checkAndRun pre-triggers
            si.postCall = !(si.preCall = true); // only evalute pre calls
            for (let idx in this.triggerList) {
                let trigger = this.triggerList[idx];
                trigger.run(si);
            }

            // run the wrapped function
            var ret, exception;
            try {
                ret = this.wrapped.apply(thisArg, argList);
            } catch (ex) {
                exception = ex;
            }
            si.retVal = ret;
            si.exception = exception;

            // checkAndRun post-triggers
            si.postCall = !(si.preCall = false); // only evaluate post calls
            for (let idx in this.triggerList) {
                let trigger = this.triggerList[idx];
                trigger.run(si);
            }
            console.log (&quot;final si&quot;, si);

            // save call
            si.postCall = si.preCall = true; // in the future evaulate both pre and post calls
            this.callList.push(si);

            return si.retVal;
        }

        _softAssert(passed, message) {
            if (!passed) {
                this.expectMessageList.push(message);
            }

            this.expectPassed = this.expectPassed &amp;&amp; passed;
            return this.expectPassed;
        }

        /**
         * Resets the wrapper to its default state. Clears out all records of previous calls,
         * expected behaviors, pass / fail results, etc.
         * @return {Wrapper} Returns the Wrapper object so that this call can be chained
         */
        configReset() {
            this.callList = [];
            this.triggerList = [];
            this.expectMessageList = [];
            this.expectPassed = true;
            this.wrapperCookie = wrapperCookie;

            return this.chainable;
        }

        selectOneByCallNumber(num) {
            var callCount = this.callList.length;
            if (typeof num !== &quot;number&quot; || num &lt; 0) {
                throw new TypeError(&#x60;selectOneByCallNumber: bad call number argument: ${num}&#x60;);
            }
            if (num &gt;= callCount) {
                throw new RangeError(&#x60;selectOneByCallNumber: ${num} is more than the number of calls made&#x60;);
            }

            return this.callList[num];
        }

        // selectOneByArgs() {}
        // selectOneByContext() {}
        // selectOneByException() {}
        // selectOneByReturn() {}
        // selectByArgs() {}
        // selectByContext() {}
        // selectByException() {}
        // selectByReturn() {}

        expectCallCount(count) {
            var passed = (this.callList.length === count);

            this._softAssert(passed, &#x60;expected to be called ${count} times&#x60;);

            return passed;
        }

        expectCallCountRange(min, max) {
            var callCount = this.callList.length;
            var passed = (callCount &gt;= min) &amp;&amp; (callCount &lt;= max);

            this._softAssert(passed, &#x60;expected to be called between ${min} and ${max} times, was called ${callCount} times&#x60;);

            return passed;
        }

        triggerAlways() {
            var t = new Trigger(this, function() {
                return true;
            });
            this.triggerList.push(t);
            return t;
        }
    }

    class SingleInvocation extends Expect {
        constructor(thisArg, argList, retVal, exception) {
            super();
            // this.calledWithNew = thisArg.new &amp;&amp; thisArg.new.target;
            this.preCall = false;
            this.postCall = false;
            this.thisArg = thisArg;
            this.argList = argList;
            this.retVal = retVal;
            this.exception = exception;
        }
    }

    class Trigger extends Expect {
        constructor(wrapper, triggerFn) {
            super();
            this.wrapper = wrapper;
            this.triggerFn = triggerFn;
            this.currentCall = null;
            this.actionList = [];
        }

        run(si) {
            console.log(&quot;run&quot;);
            // check trigger to see if it should run
            if (!this.triggerFn.call(this, si)) return;

            // perform actions
            this.currentCall = si;
            console.log (&quot;actionList&quot;, this.actionList);
            for (let idx in this.actionList) {
                let action = this.actionList[idx];
                console.log (&quot;action name&quot;, action.name);
                console.log (&quot;action args&quot;, action.args);
                this[action.name](...action.args);
            }
            this.currentCall = null;
        }

        actionReturn(retVal) {
            console.log (&quot;actionReturn:&quot;, retVal);
            // get the current call, or save the args for when the call is actually run
            var curr = this.getCurrCallOrDefer(&quot;actionReturn&quot;, retVal);
            console.log (&quot;curr&quot;, curr);
            // if there isn&#x27;t a current call, return &#x27;this&#x27; to enable chaining
            if (!curr || !curr.postCall) return this; // chainable
            // run the action
            console.log (&quot;!!! SET RETVAL&quot;);
            curr.retVal = retVal;
            console.log (&quot;set curr&quot;, curr);

            return this;
        }
    }

    class Match {
        constructor(opts) {
            // if !opts throw
            if (opts.value !== undefined) {
                this.value = opts.value;
                // } else if (opts.type) {
                //     this.type = opts.type;
                // } else if (opts.custom) {
                //     this.custom = opts.custom;
            } else {
                throw new TypeError(&quot;Match: requires a value or type to match&quot;);
            }

            this.strict = true;
            this.matcherList = new Map();
            this.matcherHierarchy = [];
            this.extend(&quot;number&quot;, null, testNumber, diffNumber);
            this.extend(&quot;array&quot;, null, testArray, diffArray);
            this.extend(&quot;object&quot;, null, testObject, diffObject);
            this.extend(&quot;string&quot;, null, testString, diffString);
            this.extend(&quot;null&quot;, null, testNull, diffNull);
            this.extend(&quot;boolean&quot;, null, testBoolean, diffBoolean);
            this.extend(&quot;undefined&quot;, null, testUndef, diffUndef);
            this.extend(&quot;date&quot;, &quot;object&quot;, testDate, diffDate);
            this.extend(&quot;regexp&quot;, &quot;object&quot;, testRegex, diffRegex);
            this.extend(&quot;singleinvocation&quot;, &quot;object&quot;, testSingleInvocation, diffSingleInvocation);
        }

        compare(any) {
            var d = this.diff(this.value, any);
            if (d.length === 0) return true;
            // TODO: if allowUndefined -- filter undefined

            return false;
        }

        // compareType

        diff(v1, v2) {
            var matcher = this.findCommonType(v1, v2);
            console.log(&quot;diff: matcher:&quot;, matcher);
            if (!matcher) {
                console.log(&quot;common type not found, returning diff&quot;);
                // throw new TypeError(&quot;diff: can&#x27;t compare uncommon values&quot;);
                return newDiff(v1, v2);
            }
            this.lastDiff = matcher.diff.call(this, v1, v2);
            return this.lastDiff;
        }

        getType(any, matcherList) {
            if (!matcherList) {
                matcherList = this.matcherHierarchy;
            }

            // check for the type in the provided list
            for (let i = 0; i &lt; matcherList.length; i++) {
                let matcher = matcherList[i];
                if (matcher.test(any)) {
                    console.log(&quot;matcher found:&quot;, matcher.name);
                    // recursively check any children for the type
                    let nextType = this.getType(any, matcher.children);
                    console.log(&quot;next type:&quot;, nextType);
                    return (nextType ? nextType : matcher);
                } else {
                    console.log(&quot;didn&#x27;t match:&quot;, matcher.name);
                }
            }

            return null;
        }

        findCommonType(matcher1, matcher2) {
            // convert values to matchers
            if (!this.isMatcher(matcher1)) {
                debug(&quot;findCommonType: converting matcher1 value to matcher:&quot;, matcher1);
                matcher1 = this.getType(matcher1);
                console.log(&quot;matcher1:&quot;, matcher1);
            }
            if (!this.isMatcher(matcher2)) {
                debug(&quot;findCommonType: converting matcher2 value to matcher:&quot;, matcher2);
                matcher2 = this.getType(matcher2);
                console.log(&quot;matcher2:&quot;, matcher2);
            }

            if (!matcher1 || !matcher2) {
                // throw new TypeError (&quot;findCommonType: couldn&#x27;t identify types to match&quot;);
                return null;
            }

            var m1types = [];
            var m2types = [];

            // make a list of the names of all the parents
            var p = matcher1;
            while (p) {
                m1types.unshift(p.name);
                p = p.parent;
            }

            p = matcher2;
            while (p) {
                m2types.unshift(p.name);
                p = p.parent;
            }
            debug(&quot;m1types&quot;, m1types);
            debug(&quot;m2types&quot;, m2types);

            // find the furthest most common type
            var commonType = null;
            for (let i = 0; i &lt; m1types.length; i++) {
                if (m1types[i] === m2types[i]) {
                    commonType = m1types[i];
                } else {
                    break;
                }
            }
            console.log(&quot;commonType:&quot;, commonType);

            // resolve common type name to matcher object
            if (commonType) {
                commonType = this.matcherList.get(commonType);
            }

            return commonType;
        }

        isMatcher(matcher) {
            console.log(&quot;isMatcher:&quot;, matcher);
            return (typeof matcher === &quot;object&quot; &amp;&amp;
                matcher !== null &amp;&amp;
                typeof matcher.name === &quot;string&quot; &amp;&amp;
                typeof matcher.test === &quot;function&quot; &amp;&amp;
                typeof matcher.diff === &quot;function&quot; &amp;&amp;
                Array.isArray(matcher.children) &amp;&amp;
                (
                    matcher.parent === null ||
                    this.isMatcher(matcher.parent)
                ));
        }

        extend(name, parentName, testFn, diffFn) {
            if (this.matcherList.has(name)) {
                throw new TypeError(&#x60;Match.extend: ${name} already exists&#x60;);
            }

            var parentMatcher = this.matcherList.get(parentName);
            parentMatcher = parentMatcher || null;

            var matcher = {
                name: name,
                test: testFn,
                diff: diffFn,
                parent: parentMatcher,
                children: []
            };

            this.matcherList.set(name, matcher);
            if (!parentMatcher) {
                this.matcherHierarchy.push(matcher);
            } else {
                parentMatcher.children.push(matcher);
            }
        }

        getLastDiff() {
            return this.lastDiff;
        }
    }

    /***************************************************
     * helper functions for testing various data types
     ****************************************************/

    function newDiff(v1, v2, key) {
        if (key !== undefined) {
            return [{
                key: key,
                src: v1,
                dst: v2
            }];
        } else {
            return [{
                src: v1,
                dst: v2
            }];
        }

    }

    function testNumber(n) {
        if (typeof n === &quot;number&quot;) return true;
        return false;
    }

    function diffNumber(n1, n2) {
        if (n1 !== n2) return newDiff(n1, n2);

        return [];
    }

    function testString(s) {
        if (typeof s === &quot;string&quot;) return true;
        return false;
    }

    function diffString(s1, s2) {
        if (s1 !== s2) return newDiff(s1, s2);

        return [];
    }

    function testObject(o) {
        if (typeof o === &quot;object&quot; &amp;&amp; o !== null) return true;
        return false;
    }

    function addKeyToDiff(d, key) {
        for (let i = 0; i &lt; d.length; i++) {
            d[i].key = key;
        }

        return d;
    }

    function diffObject(o1, o2) {
        var diff = [];

        // make a list of all the keys between the two objects
        var keyList = new Set();
        for (let key in o1) {
            keyList.add(key);
        }
        for (let key in o2) {
            keyList.add(key);
        }

        // for the combined list of keys, create a list of different keys or different values
        for (let key of keyList) {
            if ((key in o1) &amp;&amp; (key in o2)) {
                let d = this.diff(o1[key], o2[key]);
                addKeyToDiff(d, key);
                diff = diff.concat(d);
            } else {
                diff = diff.concat(newDiff(o1[key], o2[key], key));
            }
        }

        console.log(&quot;returning diff:&quot;, diff);
        return diff;
    }

    function testArray(a) {
        if (Array.isArray(a)) return true;
        return false;
    }

    function diffArray(a1, a2) {
        var diff = [];

        if (!Array.isArray(a1) || !Array.isArray(a2)) {
            throw new TypeError(&quot;diffArray got non-array&quot;);
        }

        // for the longer of the arrays, create a list of different values
        var len = (a1.length &gt; a2.length) ? a1.length : a2.length;
        for (let i = 0; i &lt; len; i++) {
            // recursive diff
            let d = this.diff(a1[i], a2[i]);
            if (d.length &gt; 0) {
                diff = diff.concat(newDiff(a1[i], a2[i], i));
            }
        }

        return diff;
    }

    function testNull(n) {
        if (n === null) return true;
        return false;
    }

    function diffNull(n1, n2) {
        if (n1 !== n2) return newDiff(n1, n2);
        return [];
    }

    function testBoolean(b) {
        if (typeof b === &quot;boolean&quot;) return true;
        return false;
    }

    function diffBoolean(b1, b2) {
        console.log(&quot;diff boolean:&quot;, b1, &quot;,&quot;, b2);
        if (b1 !== b2) return newDiff(b1, b2);
        return [];
    }

    function testDate(d) {
        if (d instanceof Date) return true;
        return false;
    }

    function diffDate(d1, d2) {
        if (d1.getTime() !== d2.getTime()) return newDiff(d1, d2);
        return [];
    }

    function testSingleInvocation(si) {
        if (si instanceof SingleInvocation) return true;
        return false;
    }

    function testUndef(u) {
        if (u === undefined) return true;
        return false;
    }

    function diffUndef(u1, u2) {
        if (u1 !== u2) return newDiff(u1, u2);
        return [];
    }

    function testRegex(rex) {
        if (rex instanceof RegExp) return true;
        return false;
    }

    function diffRegex(rex1, rex2) {
        if (rex1.toString !== rex2.toString) return newDiff(rex1.toString, rex2.toString);
        return [];
    }

    function diffSingleInvocation(si1, si2) {
        console.log(&quot;si1.argList&quot;, si1.argList);
        console.log(&quot;si2.argList&quot;, si2.argList);
        var argDiff = addKeyToDiff(this.diff(si1.argList, si2.argList), &quot;argList&quot;);
        var thisDiff = addKeyToDiff(this.diff(si1.thisArg, si2.thisArg), &quot;thisArg&quot;);
        var retDiff = addKeyToDiff(this.diff(si1.retVal, si2.retVal), &quot;retVal&quot;);
        var exDiff = addKeyToDiff(this.diff(si1.exception, si2.exception), &quot;exception&quot;);

        return [].concat(argDiff, thisDiff, retDiff, exDiff);
    }

    // Just return a value to define the module export.
    // This example returns an object, but the module
    // can return a function as the exported value.
    return {
        Wrapper: Wrapper,
        SingleInvocation: SingleInvocation,
        Match: Match,
        Trigger: Trigger
    };
}));

/* JSHINT */
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
