<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>candy-wrapper.js - Candy Wrapper</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Candy Wrapper" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Wrapper.html">Wrapper</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: candy-wrapper.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
// UMD returnExports design pattern
(function(root, factory) {
    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof module === &quot;object&quot; &amp;&amp; module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.CandyWrapper = factory();
    }
}(this, function() {

    function debug(...args) {
        // console.log(...args);
    }

    var wrapperCookie = &quot;193fe616-09d1-4d5c-a5b9-ff6f3e79714c&quot;;
    var wrapperCookieKey = &quot;uniquePlaceToKeepAGuidForCandyWrapper&quot;;

    /**
     * Creates a new function wrapper -- a spy, stub, mock, etc.
     * @class Wrapper
     */
    class Wrapper extends Function {

        constructor() {
            super();

            // if one of our subclasses is calling us, just reset and move on
            if (this instanceof WrapperCall ||
                this instanceof WrapperAttr) {

                // set default values
                this.configReset();

                return this;
            }

            if (arguments[0] === null) {
                throw new TypeError(&quot;Wrapper: bad arguments to constructor. RTFM.&quot;);
            }

            // below are all the different forms of the contructor,
            // which are basically syntactic sugar for creating wrappers
            // around lots of different kinds of things

            // forms of wrapper:
            // new Wrapper()
            // new Wrapper(obj)
            // new Wrapper(func)
            // new Wrapper(obj, method)
            // new Wrapper(obj, attribute)
            // new Wrapper(obj, method, func)
            // new Wrapper(obj, attribute, func)

            // constructed like: wrapper()
            if (arguments.length === 0) {
                debug(&quot;creating empty wrapper&quot;);
                return new WrapperCall(function() {});
            }

            // constructed like: wrapper(obj)
            /**
             * Wrap all aspects of an object
             * @param  {Object} obj Object to be wrapped
             * @return {Object}    Returns an object with all methods and attributes wrapped
             * @lends Wrapper
             * @constructor
             */
            if (arguments.length === 1 &amp;&amp; typeof arguments[0] === &quot;object&quot;) {
                debug(&quot;wrapping object&quot;);
                throw new Error(&quot;not implemented&quot;);
            }

            // constructed like: wrapper(func)
            /**
             * Puts a wrapper around a function and returns it
             * @param  {Function} fn Function to be wrapped
             * @return {Wrapper}    Returns the a Proxy for a Wrapper around the function
             * @constructs
             * @memberof Wrapper
             */
            if (arguments.length === 1 &amp;&amp; typeof arguments[0] === &quot;function&quot;) {
                debug(&quot;wrapping function:&quot;, arguments[0].name);
                return new WrapperCall(arguments[0]);
            }

            // wrapper(obj, method)
            // wrapper(obj, attribute)
            if (arguments.length === 2 &amp;&amp;
                typeof arguments[0] === &quot;object&quot; &amp;&amp;
                typeof arguments[1] === &quot;string&quot;) {
                let obj = arguments[0];
                let key = arguments[1];
                debug(&quot;wrapping method or attribute:&quot;, key);
                if (typeof obj[key] === &quot;function&quot;) {
                    obj[key] = new WrapperCall(obj[key]);
                    return obj[key];
                } else {
                    return new WrapperAttr(obj, key);
                }
            }

            // wrapper(obj, method, func)
            // wrapper(obj, attribute, func)
            if (arguments.length === 3 &amp;&amp;
                typeof arguments[0] === &quot;object&quot; &amp;&amp;
                typeof arguments[1] === &quot;string&quot; &amp;&amp;
                typeof arguments[2] === &quot;function&quot;) {
                let obj = arguments[0];
                let key = arguments[1];
                let fn = arguments[2];
                debug(&quot;wrapping method or attribute:&quot;, key);
                if (typeof obj[key] === &quot;function&quot;) {
                    return new WrapperCall(obj[key], fn);
                } else {
                    return new WrapperAttr(obj, key, fn);
                }
            }

            throw new TypeError(&quot;Wrapper: bad arguments to constructor. RTFM.&quot;);
        }

        _softAssert(passed, message) {
            if (!passed) {
                this.expectMessageList.push(message);
            }

            this.expectPassed = this.expectPassed &amp;&amp; passed;
            return this.expectPassed;
        }

        _runTriggerList(preOrPost, single) {
            if (preOrPost === &quot;pre&quot;) {
                single.postCall = !(single.preCall = true); // only evalute pre calls
            } else { // post
                single.postCall = !(single.preCall = false); // only evaluate post calls
            }

            debug(&#x60;_runTriggerList ${preOrPost}&#x60;, this.triggerList);

            for (let idx in this.triggerList) {
                let trigger = this.triggerList[idx];
                trigger.run(single);
            }
        }

        _attrOnly(callerName) {
            if (this.type !== &quot;attribute&quot;) {
                throw new Error(&#x60;${callerName} is only supported for ATTRIBUTE wrappers&#x60;);
            }
        }

        _funcOnly(callerName) {
            if (this.type !== &quot;function&quot;) {
                throw new Error(&#x60;${callerName} is only supported for FUNCTION wrappers&#x60;);
            }
        }

        static isWrapper() {
            // called like: isWrapper(fn)
            // checking to see if a function / method is a wrapper
            if (arguments.length === 1 &amp;&amp; typeof arguments[0] === &quot;function&quot;) {
                let w = arguments[0];
                // console.log (&quot;w&quot;, w);
                if (w[wrapperCookieKey] === wrapperCookie) return true;
                return false;
            }

            // called like: isWrapper(obj, method)
            if (arguments.length === 2 &amp;&amp;
                typeof arguments[0] === &quot;object&quot; &amp;&amp;
                typeof arguments[1] === &quot;string&quot;) {
                let obj = arguments[0];
                let key = arguments[1];

                // attribute is a function
                if (typeof obj[key] === &quot;function&quot;)
                    return Wrapper.isWrapper(obj[key]);

                if (typeof obj[key] === &quot;object&quot;)
                    return false;

                let desc = Object.getOwnPropertyDescriptor(obj, key);
                if (typeof desc.set !== &quot;function&quot; ||
                    typeof desc.get !== &quot;function&quot;)
                    return false;
                return (Wrapper.isWrapper(desc.set) &amp;&amp; Wrapper.isWrapper(desc.get));
            }

            throw new TypeError(&quot;isWrapper: unsupported arguments&quot;);
        }

        /**
         * Resets the wrapper to its default state. Clears out all records of previous calls,
         * expected behaviors, pass / fail results, etc.
         * @return {Wrapper} Returns the Wrapper object so that this call can be chained
         */
        configReset() {
            this.triggerList = [];
            this.expectMessageList = [];
            this.expectPassed = true;
            this[wrapperCookieKey] = wrapperCookie;

            return this.chainable;
        }

        triggerAlways() {
            var t = new Trigger(this, function() {
                return true;
            });
            this.triggerList.push(t);
            return t;
        }
    }

    class WrapperAttr extends Wrapper {
        constructor(obj, attr) {
            super();

            if (typeof obj[attr] === &quot;object&quot;) {
                throw new TypeError(&quot;can&#x27;t wrap a sub-object: not implemented&quot;);
            }

            // save the values
            this.origAttr = Object.getOwnPropertyDescriptor(obj, attr);
            this.attrValue = this.origAttr.value;
            this.type = &quot;attribute&quot;;

            // // create a proxy for the setter / getters
            // this.chainable = new Proxy(this, {
            //     apply: (target, thisArg, argList) =&gt; {
            //         if (argList.length &lt; 1 || argList.length &gt; 2) {
            //             throw new Error(&quot;Wrong number of args to setter / getter. (How is that even possible?)&quot;);
            //         }
            //         console.log(&quot;type&quot;, argList[0]);
            //         console.log(&quot;value&quot;, argList[1]);
            //         return this._doSetterGetter(argList[0], argList[1]);
            //     }
            // });

            // // bind this and the first arg to help identify the call
            // var setter = this.chainable.bind(this, &quot;set&quot;);
            // var getter = this.chainable.bind(this, &quot;get&quot;);

            // create a proxy for the setter / getters
            this.chainable = new Proxy(this, {
                apply: (target, thisArg, argList) =&gt; {
                    switch (argList.length) {
                        case 0:
                            return this._doSetterGetter(&quot;get&quot;);
                        case 1:
                            return this._doSetterGetter(&quot;set&quot;, argList[0]);
                        default:
                            throw new Error(&quot;Wrong number of args to setter / getter. (How is that even possible?)&quot;);
                    }
                }
            });

            // define the new property
            Object.defineProperty(obj, attr, {
                configurable: this.origAttr.configurable,
                enumerable: this.origAttr.enumerable,
                get: this.chainable,
                set: this.chainable,
            });

            this.chainable = this;
            return this.chainable;
        }

        configReset() {
            super.configReset();
            this.touchList = [];
        }

        _doSetterGetter(type, val) {
            // create a new single touch instance
            var st = new SingleTouch(type, this.attrValue, val);

            debug(&#x60;_doSetterGetter ${type} &quot;${val}&quot;&#x60;);

            // run pre-call trigger
            this._runTriggerList(&quot;pre&quot;, st);

            // if setting, cache the value
            if (type === &quot;set&quot;) {
                st.retVal = st.setVal;
                this.attrValue = st.setVal;
            }

            // run post-call trigger
            this._runTriggerList(&quot;post&quot;, st);
            debug(&quot;final st&quot;, st);

            // save this touch for future reference
            this.touchList.push(st);

            // always return the value
            debug(&quot;settergetter returning&quot;, st.retVal);
            return st.retVal;
        }

        filterAttrGet() {
            return this.touchList.filter(function(element) {
                return element.type === &quot;get&quot;;
            });
        }

        filterAttrSet() {
            return this.touchList.filter(function(element) {
                return element.type === &quot;set&quot;;
            });
        }

        // expectGetCount
        // expectSetCount
        // expectTouchCount
        // expectGetCountRange
        // expectSetCountRange
        // expectTouchCountRange
    }

    class WrapperCall extends Wrapper {
        constructor(origFn, wrappedFn) {
            super();

            this.type = &quot;function&quot;;
            this.orig = origFn;
            wrappedFn = wrappedFn || origFn;
            this.wrapped = wrappedFn;
            this.chainable = new Proxy(this, {
                apply: (target, thisArg, argList) =&gt; this._doCall(target, thisArg, argList)
            });

            return this.chainable;
        }

        configReset() {
            super.configReset();
            this.callList = [];
        }

        _doCall(target, thisArg, argList) {
            var funcName = this.wrapped.name || &quot;&lt;&lt;anonymous&gt;&gt;&quot;;
            debug(&#x60;calling wrapper on &quot;${funcName}&quot;&#x60;);

            var si = new SingleCall(thisArg, argList);

            // run pre-call triggers
            this._runTriggerList(&quot;pre&quot;, si);

            // run the wrapped function
            var ret, exception;
            try {
                ret = this.wrapped.apply(thisArg, argList);
            } catch (ex) {
                exception = ex;
            }
            si.retVal = ret;
            si.exception = exception;

            // run post-call triggers
            this._runTriggerList(&quot;post&quot;, si);
            debug(&quot;final si&quot;, si);

            // save call
            si.postCall = si.preCall = true; // in the future evaulate both pre and post calls
            this.callList.push(si);

            return si.retVal;
        }

        expectCallCount(count) {
            var passed = (this.callList.length === count);

            this._softAssert(passed, &#x60;expected to be called ${count} times&#x60;);

            return passed;
        }

        expectCallCountRange(min, max) {
            var callCount = this.callList.length;
            var passed = (callCount &gt;= min) &amp;&amp; (callCount &lt;= max);

            this._softAssert(passed, &#x60;expected to be called between ${min} and ${max} times, was called ${callCount} times&#x60;);

            return passed;
        }

        filterOneByCallNumber(num) {
            var callCount = this.callList.length;
            if (typeof num !== &quot;number&quot; || num &lt; 0) {
                throw new TypeError(&#x60;filterOneByCallNumber: bad call number argument: ${num}&#x60;);
            }
            if (num &gt;= callCount) {
                throw new RangeError(&#x60;filterOneByCallNumber: ${num} is more than the number of calls made&#x60;);
            }

            return this.callList[num];
        }

        // filterOneByArgs() {}
        // filterOneByContext() {}
        // filterOneByException() {}
        // filterOneByReturn() {}
        // filterByArgs() {}
        // filterByContext() {}
        // filterByException() {}
        // filterByReturn() {}
    }

    class Expect {
        constructor() {
            this.futureMatch = [];
        }

        addDeferredAction(name, args) {
            var action = {
                name: name,
                args: args
            };
            debug(&quot;adding action:&quot;, action);
            this.actionList.push(action);
        }

        getCurrCallOrDefer(name, ...args) {
            if (this instanceof SingleCall) return this;
            if (this instanceof SingleTouch) return this;
            if (this instanceof Trigger &amp;&amp; this.currentCall) return this.currentCall;
            var argArray = [...args];
            if (typeof this.addDeferredAction === &quot;function&quot;) return this.addDeferredAction(name, argArray);
            throw new Error(&#x60;Couldn&#x27;t figure current or how to defer for: ${name}&#x60;);
        }

        expectDoValidation(si) {
            this[this.expectType](si, this.expectParam);
        }

        expectCallArgs(...args /*, siRef */ ) {
            var passed = false;
            var newSi = new SingleCall();
            newSi.argList = args;
            var siRef;

            if (arguments.length === 2 &amp;&amp; arguments[1] instanceof SingleCall) {
                siRef = arguments[1];
            } else if (arguments.length !== 1 || !Array.isArray(args)) {
                throw new TypeError(&quot;expectCallArgs: expected a single args array for an argument&quot;);
            }

            var match = new Match(siRef);

            // if future evaluation, save the match
            this.futureMatch.push(new Match(siRef));

            // if evaluate now, check and return
            match.compare(siRef);

            return passed;
        }

        // expectCallArgs(si)
        // expectContext(si)
        // expectReturn(si)
        // expectException(si)
        // expectCustom (fn, param)
    }

    class SingleTouch extends Expect {
        constructor(type, retVal, setVal, exception) {
            super();

            this.type = type;
            this.setVal = setVal;
            this.retVal = retVal;
            this.exception = exception;
        }
    }

    class SingleCall extends Expect {
        constructor(thisArg, argList, retVal, exception) {
            super();
            // this.calledWithNew = thisArg.new &amp;&amp; thisArg.new.target;
            this.preCall = false;
            this.postCall = false;
            this.thisArg = thisArg;
            this.argList = argList;
            this.retVal = retVal;
            this.exception = exception;
        }
    }

    class Trigger extends Expect {
        constructor(wrapper, triggerFn) {
            super();
            this.wrapper = wrapper;
            this.triggerFn = triggerFn;
            this.currentCall = null;
            this.actionList = [];
        }

        run(si) {
            // check trigger to see if it should run
            if (!this.triggerFn.call(this, si)) return;

            // perform actions
            this.currentCall = si;
            debug(&quot;actionList&quot;, this.actionList);
            for (let idx in this.actionList) {
                let action = this.actionList[idx];
                this[action.name](...action.args);
            }
            this.currentCall = null;
        }

        actionReturn(retVal) {
            // get the current call, or save the args for when the call is actually run
            var curr = this.getCurrCallOrDefer(&quot;actionReturn&quot;, retVal);
            // if there isn&#x27;t a current call, return &#x27;this&#x27; to enable chaining
            if (!curr || !curr.postCall) return this; // chainable
            // run the action
            curr.retVal = retVal;

            return this;
        }
    }

    class Match {
        constructor(opts) {
            // if !opts throw
            if (opts.value !== undefined) {
                this.value = opts.value;
                // } else if (opts.type) {
                //     this.type = opts.type;
                // } else if (opts.custom) {
                //     this.custom = opts.custom;
            } else {
                throw new TypeError(&quot;Match: requires a value or type to match&quot;);
            }

            this.strict = true;
            this.matcherList = new Map();
            this.matcherHierarchy = [];
            this.extend(&quot;number&quot;, null, testNumber, diffNumber);
            this.extend(&quot;array&quot;, null, testArray, diffArray);
            this.extend(&quot;object&quot;, null, testObject, diffObject);
            this.extend(&quot;string&quot;, null, testString, diffString);
            this.extend(&quot;null&quot;, null, testNull, diffNull);
            this.extend(&quot;boolean&quot;, null, testBoolean, diffBoolean);
            this.extend(&quot;undefined&quot;, null, testUndef, diffUndef);
            this.extend(&quot;date&quot;, &quot;object&quot;, testDate, diffDate);
            this.extend(&quot;regexp&quot;, &quot;object&quot;, testRegex, diffRegex);
            this.extend(&quot;SingleCall&quot;, &quot;object&quot;, testSingleCall, diffSingleCall);
        }

        compare(any) {
            var d = this.diff(this.value, any);
            if (d.length === 0) return true;
            // TODO: if allowUndefined -- filter undefined

            return false;
        }

        // compareType

        diff(v1, v2) {
            var matcher = this.findCommonType(v1, v2);
            debug(&quot;diff: matcher:&quot;, matcher);
            if (!matcher) {
                debug(&quot;common type not found, returning diff&quot;);
                // throw new TypeError(&quot;diff: can&#x27;t compare uncommon values&quot;);
                return newDiff(v1, v2);
            }
            this.lastDiff = matcher.diff.call(this, v1, v2);
            return this.lastDiff;
        }

        getType(any, matcherList) {
            if (!matcherList) {
                matcherList = this.matcherHierarchy;
            }

            // check for the type in the provided list
            for (let i = 0; i &lt; matcherList.length; i++) {
                let matcher = matcherList[i];
                if (matcher.test(any)) {
                    debug(&quot;matcher found:&quot;, matcher.name);
                    // recursively check any children for the type
                    let nextType = this.getType(any, matcher.children);
                    debug(&quot;next type:&quot;, nextType);
                    return (nextType ? nextType : matcher);
                } else {
                    debug(&quot;didn&#x27;t match:&quot;, matcher.name);
                }
            }

            return null;
        }

        findCommonType(matcher1, matcher2) {
            // convert values to matchers
            if (!this.isMatcher(matcher1)) {
                debug(&quot;findCommonType: converting matcher1 value to matcher:&quot;, matcher1);
                matcher1 = this.getType(matcher1);
                debug(&quot;matcher1:&quot;, matcher1);
            }
            if (!this.isMatcher(matcher2)) {
                debug(&quot;findCommonType: converting matcher2 value to matcher:&quot;, matcher2);
                matcher2 = this.getType(matcher2);
                debug(&quot;matcher2:&quot;, matcher2);
            }

            if (!matcher1 || !matcher2) {
                // throw new TypeError (&quot;findCommonType: couldn&#x27;t identify types to match&quot;);
                return null;
            }

            var m1types = [];
            var m2types = [];

            // make a list of the names of all the parents
            var p = matcher1;
            while (p) {
                m1types.unshift(p.name);
                p = p.parent;
            }

            p = matcher2;
            while (p) {
                m2types.unshift(p.name);
                p = p.parent;
            }
            debug(&quot;m1types&quot;, m1types);
            debug(&quot;m2types&quot;, m2types);

            // find the furthest most common type
            var commonType = null;
            for (let i = 0; i &lt; m1types.length; i++) {
                if (m1types[i] === m2types[i]) {
                    commonType = m1types[i];
                } else {
                    break;
                }
            }
            debug(&quot;commonType:&quot;, commonType);

            // resolve common type name to matcher object
            if (commonType) {
                commonType = this.matcherList.get(commonType);
            }

            return commonType;
        }

        isMatcher(matcher) {
            debug(&quot;isMatcher:&quot;, matcher);
            return (typeof matcher === &quot;object&quot; &amp;&amp;
                matcher !== null &amp;&amp;
                typeof matcher.name === &quot;string&quot; &amp;&amp;
                typeof matcher.test === &quot;function&quot; &amp;&amp;
                typeof matcher.diff === &quot;function&quot; &amp;&amp;
                Array.isArray(matcher.children) &amp;&amp;
                (
                    matcher.parent === null ||
                    this.isMatcher(matcher.parent)
                ));
        }

        extend(name, parentName, testFn, diffFn) {
            if (this.matcherList.has(name)) {
                throw new TypeError(&#x60;Match.extend: ${name} already exists&#x60;);
            }

            var parentMatcher = this.matcherList.get(parentName);
            parentMatcher = parentMatcher || null;

            var matcher = {
                name: name,
                test: testFn,
                diff: diffFn,
                parent: parentMatcher,
                children: []
            };

            this.matcherList.set(name, matcher);
            if (!parentMatcher) {
                this.matcherHierarchy.push(matcher);
            } else {
                parentMatcher.children.push(matcher);
            }
        }

        getLastDiff() {
            return this.lastDiff;
        }
    }

    /***************************************************
     * helper functions for testing various data types
     ****************************************************/

    function newDiff(v1, v2, key) {
        if (key !== undefined) {
            return [{
                key: key,
                src: v1,
                dst: v2
            }];
        } else {
            return [{
                src: v1,
                dst: v2
            }];
        }

    }

    function testNumber(n) {
        if (typeof n === &quot;number&quot;) return true;
        return false;
    }

    function diffNumber(n1, n2) {
        if (n1 !== n2) return newDiff(n1, n2);

        return [];
    }

    function testString(s) {
        if (typeof s === &quot;string&quot;) return true;
        return false;
    }

    function diffString(s1, s2) {
        if (s1 !== s2) return newDiff(s1, s2);

        return [];
    }

    function testObject(o) {
        if (typeof o === &quot;object&quot; &amp;&amp; o !== null) return true;
        return false;
    }

    function addKeyToDiff(d, key) {
        for (let i = 0; i &lt; d.length; i++) {
            d[i].key = key;
        }

        return d;
    }

    function diffObject(o1, o2) {
        var diff = [];

        // make a list of all the keys between the two objects
        var keyList = new Set();
        for (let key in o1) {
            keyList.add(key);
        }
        for (let key in o2) {
            keyList.add(key);
        }

        // for the combined list of keys, create a list of different keys or different values
        for (let key of keyList) {
            if ((key in o1) &amp;&amp; (key in o2)) {
                let d = this.diff(o1[key], o2[key]);
                addKeyToDiff(d, key);
                diff = diff.concat(d);
            } else {
                diff = diff.concat(newDiff(o1[key], o2[key], key));
            }
        }

        debug(&quot;returning diff:&quot;, diff);
        return diff;
    }

    function testArray(a) {
        if (Array.isArray(a)) return true;
        return false;
    }

    function diffArray(a1, a2) {
        var diff = [];

        if (!Array.isArray(a1) || !Array.isArray(a2)) {
            throw new TypeError(&quot;diffArray got non-array&quot;);
        }

        // for the longer of the arrays, create a list of different values
        var len = (a1.length &gt; a2.length) ? a1.length : a2.length;
        for (let i = 0; i &lt; len; i++) {
            // recursive diff
            let d = this.diff(a1[i], a2[i]);
            if (d.length &gt; 0) {
                diff = diff.concat(newDiff(a1[i], a2[i], i));
            }
        }

        return diff;
    }

    function testNull(n) {
        if (n === null) return true;
        return false;
    }

    function diffNull(n1, n2) {
        if (n1 !== n2) return newDiff(n1, n2);
        return [];
    }

    function testBoolean(b) {
        if (typeof b === &quot;boolean&quot;) return true;
        return false;
    }

    function diffBoolean(b1, b2) {
        if (b1 !== b2) return newDiff(b1, b2);
        return [];
    }

    function testDate(d) {
        if (d instanceof Date) return true;
        return false;
    }

    function diffDate(d1, d2) {
        if (d1.getTime() !== d2.getTime()) return newDiff(d1, d2);
        return [];
    }

    function testSingleCall(si) {
        if (si instanceof SingleCall) return true;
        return false;
    }

    function testUndef(u) {
        if (u === undefined) return true;
        return false;
    }

    function diffUndef(u1, u2) {
        if (u1 !== u2) return newDiff(u1, u2);
        return [];
    }

    function testRegex(rex) {
        if (rex instanceof RegExp) return true;
        return false;
    }

    function diffRegex(rex1, rex2) {
        if (rex1.toString() !== rex2.toString()) return newDiff(rex1.toString(), rex2.toString());
        return [];
    }

    function diffSingleCall(si1, si2) {
        var argDiff = addKeyToDiff(this.diff(si1.argList, si2.argList), &quot;argList&quot;);
        var thisDiff = addKeyToDiff(this.diff(si1.thisArg, si2.thisArg), &quot;thisArg&quot;);
        var retDiff = addKeyToDiff(this.diff(si1.retVal, si2.retVal), &quot;retVal&quot;);
        var exDiff = addKeyToDiff(this.diff(si1.exception, si2.exception), &quot;exception&quot;);

        return [].concat(argDiff, thisDiff, retDiff, exDiff);
    }

    // Just return a value to define the module export.
    // This example returns an object, but the module
    // can return a function as the exported value.
    return {
        Wrapper: Wrapper,
        SingleCall: SingleCall,
        Match: Match,
        Trigger: Trigger
    };
}));

/* JSHINT */
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
